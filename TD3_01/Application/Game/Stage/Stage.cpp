#include "Stage.h"
#include <cassert>
#include <fstream>
#include "SafeDelete.h"

//using namespace std;
Camera* Stage::cameraStage_ = nullptr;

Stage::~Stage() {
	SafeDelete(model_);
	SafeDelete(modelFloor_);
	SafeDelete(modelGoal_);

	SafeDelete(obj_);
	SafeDelete(objFloor_);
	SafeDelete(objGoal_);
}

void Stage::Initialize(Camera* camera) {

	this->cameraStage_ = camera;

	//インスタンス生成
	model_ = new Model();
	modelFloor_ = new Model();
	modelGoal_ = new Model();

	obj_ = new Object3d();
	objFloor_ = new Object3d();
	objGoal_ = new Object3d();

	// モデル読み込み
	model_ = Model::LoadFromOBJ("cube", true);
	modelFloor_ = Model::LoadFromOBJ("floor", true);
	modelGoal_ = Model::LoadFromOBJ("cubeB", true);

	//3Dオブジェクトとカメラのセット
	obj_ = Object3d::Create();
	obj_->SetModel(model_);
	obj_->SetCamera(cameraStage_);

	objFloor_ = Object3d::Create();
	objFloor_->SetModel(modelFloor_);
	objFloor_->SetCamera(cameraStage_);

	objGoal_ = Object3d::Create();
	objGoal_->SetModel(modelGoal_);
	objGoal_->SetCamera(cameraStage_);

	// ステージの床を初期化
	LoadFloorBlock();
}

void Stage::StageInitialize(const std::string& stageNum) {
	// 最初に残っている要素を削除
	stageBlocks_.clear();

	// バッファをクリア
	stageCommands.str("");
	// 状態をクリア
	stageCommands.clear(std::stringstream::goodbit);

	// ステージ用ファイル読み込み
	LoadStageData(stageNum);
	// ステージファイルで各要素を設定
	LoadStageCommands();

	isGoal_ = false;
}

void Stage::Update() {

	isGoal_ = false;

	for (std::unique_ptr<StageData>& block : stageBlocks_) {
		//block->worldTransform_.UpdateMatrix();
		block->obj->SetWorldTransform(block->worldTransform_);
		block->obj->Update();
	}

	for (std::unique_ptr<StageData>& block : floorBlocks_) {
		//block->worldTransform_.UpdateMatrix();
		block->obj->SetWorldTransform(block->worldTransform_);
		block->obj->Update();
	}
}

void Stage::Draw() {
	// ステージ描画
	for (std::unique_ptr<StageData>& block : stageBlocks_) {
		if (block->type_ == BLOCK) {
			// 壁描画
			obj_->Draw(block->worldTransform_);
		}
	
		else
			if (block->type_ == GOAL) {
				// ゴール描画
			/*	block->worldTransform_.position_.y = -15.5f;*/
				objGoal_->Draw(block->worldTransform_);
			}


	}

	// 床描画
	for (std::unique_ptr<StageData>& block : floorBlocks_) {
		objFloor_->Draw(block->worldTransform_);
	}

}

void Stage::LoadStageData(const std::string& stageNum) {
	// ファイル
	std::ifstream file;
	// パスを取得
	const std::string name = "stage";
	const std::string filename = name + stageNum + ".csv";
	const std::string directoryPath = "Resource/" + name + "/";
	// ファイルを開く
	file.open(directoryPath + filename);
	assert(file.is_open());
	// ファイルの内容を文字列ストリームにコピー
	stageCommands << file.rdbuf();

	// ファイルを閉じる
	file.close();
}

void Stage::LoadStageCommands() {
	// 1行分の文字列を入れる変数
	std::string line;
	// マップチップ用変数
	int mapLine = 0;	// X
	int mapRow = 0;	// Y

	// コマンド実行ループ
	while (getline(stageCommands, line)) {
		// 1行分の文字列をストリームに変換して解析しやすくする
		std::istringstream line_stream(line);
		// 文字列
		std::string word;
		// ,区切りで行の先頭文字列を取得
		getline(line_stream, word, ',');

		// "//"から始まる行はコメント
		if (word.find("//") == 0) {
			// コメント行を読み飛ばす
			continue;
		}

		while (mapLine != STAGE_WIDTH) {
			// コマンド読み込み
			if (word.find("NONE") == 0 || word.find("0") == 0 || word.find("7") == 0) {
				// ステージのブロックを追加
				PushStageBlockList(stageBlocks_, obj_, NONE, mapLine, mapRow, stageDepth_);
				// インクリメント
				mapLine++;
			}
			else if (word.find("BLOCK") == 0 || word.find("1") == 0) {
				// ステージのブロックを追加
				PushStageBlockList(stageBlocks_, objFloor_, BLOCK, mapLine, mapRow, stageDepth_);
				// インクリメント
				mapLine++;
			}
			else if (word.find("GOAL") == 0 || word.find("6") == 0) {
				// ステージのブロックを追加
				PushStageBlockList(stageBlocks_, objGoal_, GOAL, mapLine, mapRow, stageDepth_);
				// インクリメント
				mapLine++;
			}
			// 次の内容へ
			getline(line_stream, word, ',');

		}
		// マップチップLineが10を超えたらリセットしてRowをインクリメント
		if (mapLine == STAGE_WIDTH) {
			mapLine = 0;
			mapRow++;
		}
	}
}

void Stage::LoadFloorBlock() {
	for (int i = 0; i < STAGE_HEIGHT; i++) {
		for (int j = 0; j < STAGE_WIDTH; j++) {
			// ステージのブロックを追加
			PushStageBlockList(floorBlocks_, objFloor_, BLOCK, j, i, floorDepth_);
		}
	}
}

void Stage::InitializeStageBlock(std::unique_ptr<StageData>& block, Object3d* obj, Vector3& pos, int line, int row) {
	// ワールドトランスフォームの初期化設定
	block->worldTransform_.Initialize();
	block->obj = obj;

	// スケール設定
	block->worldTransform_.scale_ = block->obj->GetScale();
	block->worldTransform_.scale_ = { magnification_, magnification_, magnification_ };

	// 座標設定
	block->worldTransform_.position_ = block->obj->GetPosition();
	block->worldTransform_.position_ = pos;

	block->line_ = line;
	block->row_ = row;

	obj->SetWorldTransform(block->worldTransform_);

	obj->Update();

}

void Stage::PushStageBlockList(std::list<std::unique_ptr<StageData>>& blocks_, Object3d* obj, int type, int line, int row, float depth) {
	// リストに入れるために新しく宣言
	std::unique_ptr<StageData> newBlock = std::make_unique<StageData>();
	// ブロックの種類
	newBlock->type_ = type;
	// 座標
	Vector3 pos;

	//中央揃えとなる様に座標を計算
	pos.x = -36.0f + (8.0f * line);
	pos.y = depth;
	pos.z = 92.0f - (8.0f * row);

	// 初期化する
	InitializeStageBlock(newBlock, obj, pos, line, row);
	// リストに追加
	blocks_.push_back(std::move(newBlock));

}

void Stage::CheckBlock(int line, int row) {
	// 範囲for
	for (std::unique_ptr<StageData>& block : stageBlocks_) {
		if (block->type_ == GOAL) {
			// 指定した番号に合った座標を返す
			if (block->line_ == line && block->row_ == row) {
				isGoal_ = true;
			}
		}
	}
}

bool Stage::CheckFloorBlock(int line, int row) {
	if (line < 0 || line > 10 || row < 0 || row > 10) {
		return true;
	}
	return false;
}

Vector3 Stage::GetBlockPosition(int line, int row) {
	// 範囲for
	for (std::unique_ptr<StageData>& block : stageBlocks_) {
		// ブロックと壁の時は返す
		if (block->type_ == BLOCK) {
			// 指定した番号に合った座標を返す
			if (block->line_ == line && block->row_ == row) {
				return block->worldTransform_.position_;
			}
		}
	}
	// なかったら0を返す
	return Vector3(0.0f, 0.0f, 0.0f);
}

Vector3 Stage::GetFloorPosition(int line, int row) {
	// 範囲for
	for (std::unique_ptr<StageData>& block : floorBlocks_) {
		// 指定した番号に合った座標を返す
		if (block->line_ == line && block->row_ == row) {
			return block->worldTransform_.position_;
		}
	}
	// なかったら0を返す
	return Vector3(0.0f, 0.0f, 0.0f);
}
